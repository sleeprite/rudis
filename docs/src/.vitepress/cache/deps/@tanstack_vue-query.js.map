{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/subscribable.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/utils.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/focusManager.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/onlineManager.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/retryer.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/notifyManager.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/removable.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/query.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/queryCache.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/mutation.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/mutationCache.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/queryClient.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/queryObserver.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/queriesObserver.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/infiniteQueryObserver.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/mutationObserver.ts", "../../../../node_modules/.pnpm/@tanstack+query-core@5.17.8/node_modules/@tanstack/query-core/src/hydration.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/utils.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useQueryClient.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/queryCache.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/mutationCache.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/queryClient.ts", "../../../../node_modules/.pnpm/@tanstack+match-sorter-utils@8.8.4/node_modules/@tanstack/match-sorter-utils/src/remove-accents.ts", "../../../../node_modules/.pnpm/@tanstack+match-sorter-utils@8.8.4/node_modules/@tanstack/match-sorter-utils/src/index.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/devtools/utils.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/devtools/devtools.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/vueQueryPlugin.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/queryOptions.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useBaseQuery.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useQuery.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useQueries.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useInfiniteQuery.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useMutation.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useIsFetching.ts", "../../../../node_modules/.pnpm/@tanstack+vue-query@5.17.8_vue@3.4.5/node_modules/@tanstack/vue-query/src/useMutationState.ts"],
  "sourcesContent": ["type Listener = () => void\n\nexport class Subscribable<TListener extends Function = Listener> {\n  protected listeners: Set<TListener>\n\n  constructor() {\n    this.listeners = new Set()\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type { Mutation } from './mutation'\nimport type { Query } from './query'\nimport type {\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryKey,\n  QueryOptions,\n} from './types'\n\n// TYPES\n\nexport interface QueryFilters {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: QueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (mutation: Mutation<any, any, any>) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in window\n\nexport function noop(): undefined {\n  return undefined\n}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (\n    typeof fetchStatus !== 'undefined' &&\n    fetchStatus !== query.state.fetchStatus\n  ) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: QueryOptions<any, any, any, TQueryKey>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aSize = array ? a.length : Object.keys(a).length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(a[key], b[key])\n      if (copy[key] === a[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\nexport function shallowEqualObjects<T>(a: T, b: T): boolean {\n  if ((a && !b) || (b && !a)) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data)\n  } else if (options.structuralSharing !== false) {\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    this.listeners.forEach((listener) => {\n      listener()\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => boolean) | undefined\n  let promiseResolve: (data: TData) => void\n  let promiseReject: (error: TError) => void\n\n  const promise = new Promise<TData>((outerResolve, outerReject) => {\n    promiseResolve = outerResolve\n    promiseReject = outerReject\n  })\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const shouldPause = () =>\n    !focusManager.isFocused() ||\n    (config.networkMode !== 'always' && !onlineManager.isOnline())\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      promiseResolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      promiseReject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        const canContinue = isResolved || !shouldPause()\n        if (canContinue) {\n          continueResolve(value)\n        }\n        return canContinue\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // Execute query\n    try {\n      promiseOrValue = config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            if (shouldPause()) {\n              return pause()\n            }\n            return\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  // Start loop\n  if (canFetch(config.networkMode)) {\n    run()\n  } else {\n    pause().then(run)\n  }\n\n  return {\n    promise,\n    cancel,\n    continue: () => {\n      const didContinue = continueFn?.()\n      return didContinue ? promise : Promise.resolve()\n    },\n    cancelRetry,\n    continueRetry,\n  }\n}\n", "// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\n  const setScheduler = (fn: ScheduleFunction) => {\n    scheduleFn = fn\n  }\n\n  const batch = <T>(callback: () => T): T => {\n    let result\n    transactions++\n    try {\n      result = callback()\n    } finally {\n      transactions--\n      if (!transactions) {\n        flush()\n      }\n    }\n    return result\n  }\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  const batchCalls = <T extends Array<unknown>>(\n    callback: BatchCallsCallback<T>,\n  ): BatchCallsCallback<T> => {\n    return (...args) => {\n      schedule(() => {\n        callback(...args)\n      })\n    }\n  }\n\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  const setNotifyFunction = (fn: NotifyFunction) => {\n    notifyFn = fn\n  }\n\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  const setBatchNotifyFunction = (fn: BatchNotifyFunction) => {\n    batchNotifyFn = fn\n  }\n\n  return {\n    batch,\n    batchCalls,\n    schedule,\n    setNotifyFunction,\n    setBatchNotifyFunction,\n    setScheduler,\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n", "import { noop, replaceData, timeUntilStale } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #promise?: Promise<TData>\n  #retryer?: Retryer<TData>\n  #observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.#setOptions(config.options)\n    this.#observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  #setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.#observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter((x) => x !== observer)\n\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.#observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.#promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.#setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.#setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: Omit<QueryFunctionContext<TQueryKey>, 'signal'> = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`),\n        )\n      }\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: Omit<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.#promise = this.#retryer.promise\n\n    return this.#promise\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'pending',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n", "import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryKey: string) => boolean\n  set: (queryKey: string, query: Query) => void\n  get: (queryKey: string) => Query | undefined\n  delete: (queryKey: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<TQueryFnData, TError, TData, TQueryKey extends QueryKey>(\n    client: QueryClient,\n    options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey!\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        cache: this,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { canFetch, createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #defaultOptions?: MutationOptions<TData, TError, TVariables, TContext>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#defaultOptions = config.defaultOptions\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options?: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const executeMutation = () => {\n      this.#retryer = createRetryer({\n        fn: () => {\n          if (!this.options.mutationFn) {\n            return Promise.reject(new Error('No mutationFn found'))\n          }\n          return this.options.mutationFn(variables)\n        },\n        onFail: (failureCount, error) => {\n          this.#dispatch({ type: 'failed', failureCount, error })\n        },\n        onPause: () => {\n          this.#dispatch({ type: 'pause' })\n        },\n        onContinue: () => {\n          this.#dispatch({ type: 'continue' })\n        },\n        retry: this.options.retry ?? 0,\n        retryDelay: this.options.retryDelay,\n        networkMode: this.options.networkMode,\n      })\n\n      return this.#retryer.promise\n    }\n\n    const restored = this.state.status === 'pending'\n\n    try {\n      if (!restored) {\n        this.#dispatch({ type: 'pending', variables })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n          })\n        }\n      }\n      const data = await executeMutation()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: !canFetch(this.options.networkMode),\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Array<Mutation<any, any, any, any>>\n  #mutationId: number\n  #resuming: Promise<unknown> | undefined\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = []\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.push(mutation)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations = this.#mutations.filter((x) => x !== mutation)\n    this.notify({ type: 'removed', mutation })\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return this.#mutations\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.#mutations.find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    )\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.#mutations.filter((mutation) =>\n      matchMutation(filters, mutation),\n    )\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    this.#resuming = (this.#resuming ?? Promise.resolve())\n      .then(() => {\n        const pausedMutations = this.#mutations.filter((x) => x.state.isPaused)\n        return notifyManager.batch(() =>\n          pausedMutations.reduce(\n            (promise, mutation) =>\n              promise.then(() => mutation.continue().catch(noop)),\n            Promise.resolve() as Promise<unknown>,\n          ),\n        )\n      })\n      .then(() => {\n        this.#resuming = undefined\n      })\n\n    return this.#resuming\n  }\n}\n", "import { addToEnd, addToStart } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn ||\n          (() =>\n            Promise.reject(\n              new Error(`Missing queryFn: '${context.options.queryHash}'`),\n            ))\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: Omit<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          // Fetch first page\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam,\n          )\n\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch remaining pages\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n", "import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { DataTag, NoInfer } from './types'\nimport type { QueryState } from './query'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  getQueryData<\n    TQueryFnData = unknown,\n    TaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = TaggedQueryKey extends DataTag<\n      unknown,\n      infer TaggedValue\n    >\n      ? TaggedValue\n      : TQueryFnData,\n  >(queryKey: TaggedQueryKey): TInferredQueryFnData | undefined\n  getQueryData(queryKey: QueryKey) {\n    return this.#queryCache.find({ queryKey })?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const cachedData = this.getQueryData<TData>(options.queryKey)\n\n    return cachedData !== undefined\n      ? Promise.resolve(cachedData)\n      : this.fetchQuery(options)\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.getQueryCache()\n      .findAll(filters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = TaggedQueryKey extends DataTag<\n      unknown,\n      infer TaggedValue\n    >\n      ? TaggedValue\n      : TQueryFnData,\n  >(\n    queryKey: TaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): TInferredQueryFnData | undefined {\n    const query = this.#queryCache.find<TInferredQueryFnData>({ queryKey })\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = DefaultError>(\n    queryKey: QueryKey,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.#queryCache.find<TQueryFnData, TError>({ queryKey })?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void> {\n    const queryCache = this.#queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(\n    filters: QueryFilters = {},\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters: InvalidateQueryFilters = {},\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries(\n    filters: RefetchQueryFilters = {},\n    options?: RefetchOptions,\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    return this.#mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: Partial<\n      Omit<QueryObserverOptions<unknown, any, any, any>, 'queryKey'>\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    let result: QueryObserverOptions<any, any, any, any, any> = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: Omit<MutationObserverOptions<any, any, any, any>, 'mutationKey'>,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    let result: MutationObserverOptions<any, any, any, any> = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options?:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...(options?.queryKey && this.getQueryDefaults(options.queryKey)),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.throwOnError === 'undefined') {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (\n      typeof defaultedOptions.networkMode === 'undefined' &&\n      defaultedOptions.persister\n    ) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n", "import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch } from './retryer'\nimport type { QueryClient } from './queryClient'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps: Set<keyof QueryObserverResult> = new Set()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.#updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult everytime\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.#currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let { error, errorUpdatedAt, fetchStatus, status } = state\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!state.dataUpdatedAt) {\n          status = 'pending'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n", "import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #observers: Array<QueryObserver>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #combinedResult!: TCombinedResult\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#queries = []\n    this.#observers = []\n\n    this.#setResult([])\n    this.setQueries(queries, options)\n  }\n\n  #setResult(value: Array<QueryObserverResult>) {\n    this.#result = value\n    this.#combinedResult = this.#combineResult(value, this.#options?.combine)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#setResult(newResult)\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): TCombinedResult {\n    return this.#combinedResult\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return matches.map((match, index) => {\n          const observerResult = result[index]!\n          return !match.defaultedQueryOptions.notifyOnChangeProps\n            ? match.observer.trackResult(observerResult)\n            : observerResult\n        })\n      },\n    ]\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      return replaceEqualDeep(this.#combinedResult, combine(input))\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObservers = this.#observers\n    const prevObserversMap = new Map(\n      prevObservers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const defaultedQueryOptions = queries.map((options) =>\n      this.#client.defaultQueryOptions(options),\n    )\n\n    const matchingObservers: Array<QueryObserverMatch> =\n      defaultedQueryOptions.flatMap((defaultedOptions) => {\n        const match = prevObserversMap.get(defaultedOptions.queryHash)\n        if (match != null) {\n          return [{ defaultedQueryOptions: defaultedOptions, observer: match }]\n        }\n        return []\n      })\n\n    const matchedQueryHashes = new Set(\n      matchingObservers.map((match) => match.defaultedQueryOptions.queryHash),\n    )\n    const unmatchedQueries = defaultedQueryOptions.filter(\n      (defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash),\n    )\n\n    const getObserver = (options: QueryObserverOptions): QueryObserver => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const currentObserver = this.#observers.find(\n        (o) => o.options.queryHash === defaultedOptions.queryHash,\n      )\n      return (\n        currentObserver ?? new QueryObserver(this.#client, defaultedOptions)\n      )\n    }\n\n    const newOrReusedObservers: Array<QueryObserverMatch> =\n      unmatchedQueries.map((options) => {\n        return {\n          defaultedQueryOptions: options,\n          observer: getObserver(options),\n        }\n      })\n\n    const sortMatchesByOrderOfQueries = (\n      a: QueryObserverMatch,\n      b: QueryObserverMatch,\n    ): number =>\n      defaultedQueryOptions.indexOf(a.defaultedQueryOptions) -\n      defaultedQueryOptions.indexOf(b.defaultedQueryOptions)\n\n    return matchingObservers\n      .concat(newOrReusedObservers)\n      .sort(sortMatchesByOrderOfQueries)\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#setResult(replaceAt(this.#result, index, result))\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(this.#result)\n      })\n    })\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n", "import { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions, ObserverFetchOptions } from './queryObserver'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  TData,\n  InfiniteData<TQueryData, TPageParam>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: (\n    listener?: InfiniteQueryObserverListener<TData, TError>,\n  ) => () => void\n\n  // Type override\n  getCurrentResult!: () => InfiniteQueryObserverResult<TData, TError>\n\n  // Type override\n  protected fetch!: (\n    fetchOptions: ObserverFetchOptions,\n  ) => Promise<InfiniteQueryObserverResult<TData, TError>>\n\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options?: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior(),\n      },\n      notifyOptions,\n    )\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward' },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward' },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<\n      TQueryFnData,\n      TError,\n      InfiniteData<TQueryData, TPageParam>,\n      TQueryKey\n    >,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const result = super.createResult(query, options)\n\n    const { isFetching, isRefetching } = result\n\n    const isFetchingNextPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'forward'\n\n    const isFetchingPreviousPage =\n      isFetching && state.fetchMeta?.fetchMore?.direction === 'backward'\n\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n  }\n}\n", "import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n    this.#currentMutation?.setOptions(this.options)\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n", "import type { QueryClient } from './queryClient'\nimport type { Query, QueryState } from './query'\nimport type {\n  MutationKey,\n  MutationMeta,\n  MutationOptions,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n} from './types'\nimport type { Mutation, MutationState } from './mutation'\n\n// TYPES\n\nexport interface DehydrateOptions {\n  shouldDehydrateMutation?: (mutation: Mutation) => boolean\n  shouldDehydrateQuery?: (query: Query) => boolean\n}\n\nexport interface HydrateOptions {\n  defaultOptions?: {\n    queries?: QueryOptions\n    mutations?: MutationOptions\n  }\n}\n\ninterface DehydratedMutation {\n  mutationKey?: MutationKey\n  state: MutationState\n  meta?: MutationMeta\n}\n\ninterface DehydratedQuery {\n  queryHash: string\n  queryKey: QueryKey\n  state: QueryState\n  meta?: QueryMeta\n}\n\nexport interface DehydratedState {\n  mutations: Array<DehydratedMutation>\n  queries: Array<DehydratedQuery>\n}\n\n// FUNCTIONS\n\nfunction dehydrateMutation(mutation: Mutation): DehydratedMutation {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...(mutation.meta && { meta: mutation.meta }),\n  }\n}\n\n// Most config is not dehydrated but instead meant to configure again when\n// consuming the de/rehydrated data, typically with useQuery on the client.\n// Sometimes it might make sense to prefetch data on the server and include\n// in the html-payload, but not consume it on the initial render.\nfunction dehydrateQuery(query: Query): DehydratedQuery {\n  return {\n    state: query.state,\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...(query.meta && { meta: query.meta }),\n  }\n}\n\nexport function defaultShouldDehydrateMutation(mutation: Mutation) {\n  return mutation.state.isPaused\n}\n\nexport function defaultShouldDehydrateQuery(query: Query) {\n  return query.state.status === 'success'\n}\n\nexport function dehydrate(\n  client: QueryClient,\n  options: DehydrateOptions = {},\n): DehydratedState {\n  const filterMutation =\n    options.shouldDehydrateMutation ?? defaultShouldDehydrateMutation\n\n  const mutations = client\n    .getMutationCache()\n    .getAll()\n    .flatMap((mutation) =>\n      filterMutation(mutation) ? [dehydrateMutation(mutation)] : [],\n    )\n\n  const filterQuery =\n    options.shouldDehydrateQuery ?? defaultShouldDehydrateQuery\n\n  const queries = client\n    .getQueryCache()\n    .getAll()\n    .flatMap((query) => (filterQuery(query) ? [dehydrateQuery(query)] : []))\n\n  return { mutations, queries }\n}\n\nexport function hydrate(\n  client: QueryClient,\n  dehydratedState: unknown,\n  options?: HydrateOptions,\n): void {\n  if (typeof dehydratedState !== 'object' || dehydratedState === null) {\n    return\n  }\n\n  const mutationCache = client.getMutationCache()\n  const queryCache = client.getQueryCache()\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const mutations = (dehydratedState as DehydratedState).mutations || []\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const queries = (dehydratedState as DehydratedState).queries || []\n\n  mutations.forEach((dehydratedMutation) => {\n    mutationCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.mutations,\n        mutationKey: dehydratedMutation.mutationKey,\n        meta: dehydratedMutation.meta,\n      },\n      dehydratedMutation.state,\n    )\n  })\n\n  queries.forEach(({ queryKey, state, queryHash, meta }) => {\n    const query = queryCache.get(queryHash)\n\n    // Do not hydrate if an existing query exists with newer data\n    if (query) {\n      if (query.state.dataUpdatedAt < state.dataUpdatedAt) {\n        // omit fetchStatus from dehydrated state\n        // so that query stays in its current fetchStatus\n        const { fetchStatus: _ignored, ...dehydratedQueryState } = state\n        query.setState(dehydratedQueryState)\n      }\n      return\n    }\n\n    // Restore query\n    queryCache.build(\n      client,\n      {\n        ...options?.defaultOptions?.queries,\n        queryKey,\n        queryHash,\n        meta,\n      },\n      // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      {\n        ...state,\n        fetchStatus: 'idle',\n      },\n    )\n  })\n}\n", "import { isRef, unref } from 'vue-demi'\nimport type { MaybeRefDeep } from './types'\n\nexport const VUE_QUERY_CLIENT = 'VUE_QUERY_CLIENT'\n\nexport function getClientKey(key?: string) {\n  const suffix = key ? `:${key}` : ''\n  return `${VUE_QUERY_CLIENT}${suffix}`\n}\n\nexport function updateState(\n  state: Record<string, unknown>,\n  update: Record<string, any>,\n): void {\n  Object.keys(state).forEach((key) => {\n    state[key] = update[key]\n  })\n}\n\nexport function cloneDeep<T>(\n  value: MaybeRefDeep<T>,\n  customizer?: (val: MaybeRefDeep<T>) => T | undefined,\n): T {\n  if (customizer) {\n    const result = customizer(value)\n    // If it's a ref of undefined, return undefined\n    if (result === undefined && isRef(value)) {\n      return result as T\n    }\n    if (result !== undefined) {\n      return result\n    }\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((val) => cloneDeep(val, customizer)) as unknown as T\n  }\n\n  if (typeof value === 'object' && isPlainObject(value)) {\n    const entries = Object.entries(value).map(([key, val]) => [\n      key,\n      cloneDeep(val, customizer),\n    ])\n    return Object.fromEntries(entries)\n  }\n\n  return value as T\n}\n\nexport function cloneDeepUnref<T>(obj: MaybeRefDeep<T>): T {\n  return cloneDeep(obj, (val) => {\n    if (isRef(val)) {\n      return cloneDeepUnref(unref(val))\n    }\n\n    return undefined\n  })\n}\n\nfunction isPlainObject(value: unknown): value is Object {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n", "import { hasInjectionContext, inject } from 'vue-demi'\n\nimport { getClientKey } from './utils'\nimport type { QueryClient } from './queryClient'\n\nexport function useQueryClient(id = ''): QueryClient {\n  // ensures that `inject()` can be used\n  if (!hasInjectionContext()) {\n    throw new Error(\n      'vue-query hooks can only be used inside setup() function or functions that support injection context.',\n    )\n  }\n\n  const key = getClientKey(id)\n  const queryClient = inject<QueryClient>(key)\n\n  if (!queryClient) {\n    throw new Error(\n      \"No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library.\",\n    )\n  }\n\n  return queryClient\n}\n", "import { QueryCache as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport type {\n  DefaultError,\n  Query,\n  QueryFilters,\n  WithRequired,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class QueryCache extends QC {\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: MaybeRefDeep<WithRequired<QueryFilters, 'queryKey'>>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    return super.find(cloneDeepUnref(filters))\n  }\n\n  findAll(filters: MaybeRefDeep<QueryFilters> = {}): Array<Query> {\n    return super.findAll(cloneDeepUnref(filters))\n  }\n}\n", "import { MutationCache as MC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport type {\n  DefaultError,\n  Mutation,\n  MutationFilters,\n} from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\n\nexport class MutationCache extends MC {\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MaybeRefDeep<MutationFilters>,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    return super.find(cloneDeepUnref(filters))\n  }\n\n  findAll(filters: MaybeRefDeep<MutationFilters> = {}): Array<Mutation> {\n    return super.findAll(cloneDeepUnref(filters))\n  }\n}\n", "import { ref } from 'vue-demi'\nimport { QueryClient as QC } from '@tanstack/query-core'\nimport { cloneDeepUnref } from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport type { MaybeRefDeep, NoUnknown } from './types'\nimport type {\n  CancelOptions,\n  DataTag,\n  DefaultError,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationFilters,\n  MutationKey,\n  MutationObserverOptions,\n  NoInfer,\n  QueryClientConfig,\n  QueryFilters,\n  QueryKey,\n  QueryObserverOptions,\n  QueryState,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/query-core'\n\nexport class QueryClient extends QC {\n  constructor(config: QueryClientConfig = {}) {\n    const vueQueryConfig = {\n      defaultOptions: config.defaultOptions,\n      queryCache: config.queryCache || new QueryCache(),\n      mutationCache: config.mutationCache || new MutationCache(),\n    }\n    super(vueQueryConfig)\n  }\n\n  isRestoring = ref(false)\n\n  isFetching(filters: MaybeRefDeep<QueryFilters> = {}): number {\n    return super.isFetching(cloneDeepUnref(filters))\n  }\n\n  isMutating(filters: MaybeRefDeep<MutationFilters> = {}): number {\n    return super.isMutating(cloneDeepUnref(filters))\n  }\n\n  getQueryData<TData = unknown, TaggedQueryKey extends QueryKey = QueryKey>(\n    queryKey: MaybeRefDeep<TaggedQueryKey>,\n  ):\n    | (TaggedQueryKey extends DataTag<unknown, infer TaggedValue>\n        ? TaggedValue\n        : TData)\n    | undefined\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): TData | undefined\n  getQueryData<TData = unknown>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): TData | undefined {\n    return super.getQueryData(cloneDeepUnref(queryKey))\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData>\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<TData> {\n    return super.ensureQueryData(cloneDeepUnref(options))\n  }\n\n  getQueriesData<TData = unknown>(\n    filters: MaybeRefDeep<QueryFilters>,\n  ): Array<[QueryKey, TData | undefined]> {\n    return super.getQueriesData(cloneDeepUnref(filters))\n  }\n\n  setQueryData<\n    TQueryFnData,\n    TaggedQueryKey extends QueryKey,\n    TData = TaggedQueryKey extends DataTag<unknown, infer TaggedValue>\n      ? TaggedValue\n      : TQueryFnData,\n  >(\n    queryKey: MaybeRefDeep<TaggedQueryKey>,\n    updater: Updater<NoInfer<TData> | undefined, NoInfer<TData> | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): TData | undefined\n  setQueryData<TQueryFnData, TData = NoUnknown<TQueryFnData>>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<NoInfer<TData> | undefined, NoInfer<TData> | undefined>,\n    options?: MaybeRefDeep<SetDataOptions>,\n  ): TData | undefined\n  setQueryData<TData>(\n    queryKey: MaybeRefDeep<QueryKey>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options: MaybeRefDeep<SetDataOptions> = {},\n  ): TData | undefined {\n    return super.setQueryData(\n      cloneDeepUnref(queryKey),\n      updater,\n      cloneDeepUnref(options),\n    )\n  }\n\n  setQueriesData<TData>(\n    filters: MaybeRefDeep<QueryFilters>,\n    updater: Updater<TData | undefined, TData | undefined>,\n    options: MaybeRefDeep<SetDataOptions> = {},\n  ): Array<[QueryKey, TData | undefined]> {\n    return super.setQueriesData(\n      cloneDeepUnref(filters),\n      updater,\n      cloneDeepUnref(options),\n    )\n  }\n\n  getQueryState<TData = unknown, TError = DefaultError>(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): QueryState<TData, TError> | undefined {\n    return super.getQueryState(cloneDeepUnref(queryKey))\n  }\n\n  removeQueries(filters: MaybeRefDeep<QueryFilters> = {}): void {\n    return super.removeQueries(cloneDeepUnref(filters))\n  }\n\n  resetQueries(\n    filters: MaybeRefDeep<QueryFilters> = {},\n    options: MaybeRefDeep<ResetOptions> = {},\n  ): Promise<void> {\n    return super.resetQueries(cloneDeepUnref(filters), cloneDeepUnref(options))\n  }\n\n  cancelQueries(\n    filters: MaybeRefDeep<QueryFilters> = {},\n    options: MaybeRefDeep<CancelOptions> = {},\n  ): Promise<void> {\n    return super.cancelQueries(cloneDeepUnref(filters), cloneDeepUnref(options))\n  }\n\n  invalidateQueries(\n    filters: MaybeRefDeep<InvalidateQueryFilters> = {},\n    options: MaybeRefDeep<InvalidateOptions> = {},\n  ): Promise<void> {\n    // (dosipiuk): We need to delay `invalidate` execution to next macro task for all reactive values to be updated.\n    // This ensures that `context` in `queryFn` while `invalidating` along reactive variable change has correct value.\n    return new Promise((resolve) => {\n      setTimeout(async () => {\n        await super.invalidateQueries(\n          cloneDeepUnref(filters),\n          cloneDeepUnref(options),\n        )\n        resolve()\n      }, 0)\n    })\n  }\n\n  refetchQueries(\n    filters: MaybeRefDeep<RefetchQueryFilters> = {},\n    options: MaybeRefDeep<RefetchOptions> = {},\n  ): Promise<void> {\n    return super.refetchQueries(\n      cloneDeepUnref(filters),\n      cloneDeepUnref(options),\n    )\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n    >,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n    >,\n  ): Promise<TData> {\n    return super.fetchQuery(cloneDeepUnref(options))\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: MaybeRefDeep<\n      FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n    >,\n  ): Promise<void> {\n    return super.prefetchQuery(cloneDeepUnref(options))\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    return super.fetchInfiniteQuery(cloneDeepUnref(options))\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: MaybeRefDeep<\n      FetchInfiniteQueryOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryKey,\n        TPageParam\n      >\n    >,\n  ): Promise<void> {\n    return super.prefetchInfiniteQuery(cloneDeepUnref(options))\n  }\n\n  setDefaultOptions(options: MaybeRefDeep<DefaultOptions>): void {\n    super.setDefaultOptions(cloneDeepUnref(options))\n  }\n\n  setQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n    options: MaybeRefDeep<\n      Omit<QueryObserverOptions<unknown, any, any, any>, 'queryKey'>\n    >,\n  ): void {\n    super.setQueryDefaults(cloneDeepUnref(queryKey), cloneDeepUnref(options))\n  }\n\n  getQueryDefaults(\n    queryKey: MaybeRefDeep<QueryKey>,\n  ): QueryObserverOptions<any, any, any, any, any> {\n    return super.getQueryDefaults(cloneDeepUnref(queryKey))\n  }\n\n  setMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n    options: MaybeRefDeep<MutationObserverOptions<any, any, any, any>>,\n  ): void {\n    super.setMutationDefaults(\n      cloneDeepUnref(mutationKey),\n      cloneDeepUnref(options),\n    )\n  }\n\n  getMutationDefaults(\n    mutationKey: MaybeRefDeep<MutationKey>,\n  ): MutationObserverOptions<any, any, any, any> {\n    return super.getMutationDefaults(cloneDeepUnref(mutationKey))\n  }\n}\n", "const characterMap: Record<string, string> = {\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'AE',\n  : 'A',\n  : 'A',\n  : 'A',\n  : 'C',\n  : 'C',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'E',\n  : 'I',\n  : 'I',\n  : 'I',\n  : 'I',\n  : 'I',\n  : 'I',\n  : 'D',\n  : 'N',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'O',\n  : 'U',\n  : 'U',\n  : 'U',\n  : 'U',\n  : 'Y',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'ae',\n  : 'a',\n  : 'a',\n  : 'a',\n  : 'c',\n  : 'c',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'e',\n  : 'i',\n  : 'i',\n  : 'i',\n  : 'i',\n  : 'i',\n  : 'i',\n  : 'd',\n  : 'n',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'o',\n  : 'u',\n  : 'u',\n  : 'u',\n  : 'u',\n  : 'y',\n  : 'y',\n  : 'A',\n  : 'a',\n  : 'A',\n  : 'a',\n  : 'A',\n  : 'a',\n  : 'C',\n  : 'c',\n  : 'C',\n  : 'c',\n  : 'C',\n  : 'c',\n  : 'C',\n  : 'c',\n  C: 'C',\n  c: 'c',\n  : 'D',\n  : 'd',\n  : 'D',\n  : 'd',\n  : 'E',\n  : 'e',\n  : 'E',\n  : 'e',\n  : 'E',\n  : 'e',\n  : 'E',\n  : 'e',\n  : 'E',\n  : 'e',\n  : 'G',\n  : 'G',\n  : 'g',\n  : 'g',\n  : 'G',\n  : 'g',\n  : 'G',\n  : 'g',\n  : 'G',\n  : 'g',\n  : 'H',\n  : 'h',\n  : 'H',\n  : 'h',\n  : 'H',\n  : 'h',\n  : 'I',\n  : 'i',\n  : 'I',\n  : 'i',\n  : 'I',\n  : 'i',\n  : 'I',\n  : 'i',\n  : 'I',\n  : 'i',\n  : 'IJ',\n  : 'ij',\n  : 'J',\n  : 'j',\n  : 'K',\n  : 'k',\n  : 'K',\n  : 'k',\n  K: 'K',\n  k: 'k',\n  : 'L',\n  : 'l',\n  : 'L',\n  : 'l',\n  : 'L',\n  : 'l',\n  : 'L',\n  : 'l',\n  : 'l',\n  : 'l',\n  : 'M',\n  : 'm',\n  M: 'M',\n  m: 'm',\n  : 'N',\n  : 'n',\n  : 'N',\n  : 'n',\n  : 'N',\n  : 'n',\n  : 'n',\n  N: 'N',\n  n: 'n',\n  : 'O',\n  : 'o',\n  : 'O',\n  : 'o',\n  : 'O',\n  : 'o',\n  : 'OE',\n  : 'oe',\n  P: 'P',\n  p: 'p',\n  : 'R',\n  : 'r',\n  : 'R',\n  : 'r',\n  : 'R',\n  : 'r',\n  R: 'R',\n  r: 'r',\n  : 'R',\n  : 'r',\n  : 'S',\n  : 's',\n  : 'S',\n  : 's',\n  : 'S',\n  : 'S',\n  : 's',\n  : 's',\n  : 'S',\n  : 's',\n  : 'T',\n  : 't',\n  : 't',\n  : 'T',\n  : 'T',\n  : 't',\n  : 'T',\n  : 't',\n  T: 'T',\n  t: 't',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  V: 'V',\n  v: 'v',\n  : 'W',\n  : 'w',\n  : 'W',\n  : 'w',\n  X: 'X',\n  x: 'x',\n  : 'Y',\n  : 'y',\n  : 'Y',\n  Y: 'Y',\n  y: 'y',\n  : 'Z',\n  : 'z',\n  : 'Z',\n  : 'z',\n  : 'Z',\n  : 'z',\n  : 's',\n  : 'f',\n  : 'O',\n  : 'o',\n  : 'U',\n  : 'u',\n  : 'A',\n  : 'a',\n  : 'I',\n  : 'i',\n  : 'O',\n  : 'o',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'U',\n  : 'u',\n  : 'A',\n  : 'a',\n  : 'AE',\n  : 'ae',\n  : 'O',\n  : 'o',\n  : 'TH',\n  : 'th',\n  : 'P',\n  : 'p',\n  : 'S',\n  : 's',\n  X: 'X',\n  x: 'x',\n  : '',\n  : '',\n  : '',\n  : '',\n  A: 'A',\n  a: 'a',\n  E: 'E',\n  e: 'e',\n  I: 'I',\n  i: 'i',\n  : 'N',\n  : 'n',\n  : 'O',\n  : 'o',\n  : 'O',\n  : 'o',\n  : 'U',\n  : 'u',\n  : 'W',\n  : 'w',\n  : 'Y',\n  : 'y',\n  : 'A',\n  : 'a',\n  : 'E',\n  : 'e',\n  : 'I',\n  : 'i',\n  : 'O',\n  : 'o',\n  : 'R',\n  : 'r',\n  : 'U',\n  : 'u',\n  B: 'B',\n  b: 'b',\n  : 'C',\n  : 'c',\n  : 'E',\n  : 'e',\n  F: 'F',\n  f: 'f',\n  : 'G',\n  : 'g',\n  : 'H',\n  : 'h',\n  J: 'J',\n  : 'j',\n  : 'K',\n  : 'k',\n  M: 'M',\n  m: 'm',\n  P: 'P',\n  p: 'p',\n  Q: 'Q',\n  q: 'q',\n  : 'R',\n  : 'r',\n  : 'S',\n  : 's',\n  V: 'V',\n  v: 'v',\n  W: 'W',\n  w: 'w',\n  X: 'X',\n  x: 'x',\n  Y: 'Y',\n  y: 'y',\n  A: 'A',\n  a: 'a',\n  B: 'B',\n  b: 'b',\n  : 'D',\n  : 'd',\n  : 'E',\n  : 'e',\n  : 'E',\n  : 'e',\n  : 'H',\n  : 'h',\n  I: 'I',\n  i: 'i',\n  : 'I',\n  : 'i',\n  M: 'M',\n  m: 'm',\n  O: 'O',\n  o: 'o',\n  Q: 'Q',\n  q: 'q',\n  U: 'U',\n  u: 'u',\n  X: 'X',\n  x: 'x',\n  Z: 'Z',\n  z: 'z',\n}\n\nconst chars = Object.keys(characterMap).join('|')\nconst allAccents = new RegExp(chars, 'g')\n\nexport function removeAccents(str: string) {\n  return str.replace(allAccents, match => {\n    return characterMap[match]!\n  })\n}\n", "/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */\n\n// This is a fork of match-sorter. Instead of offering\n// a unified API for filtering and sorting in a single pass,\n// match-sorter-utils provides the lower-level utilities of\n// ranking items and comparing ranks in a way that can\n// be incrementally applied to a system rather than\n// all-at-once.\n\n// 1. Use the rankItem function to rank an item\n// 2. Use the resulting rankingInfo.passed to filter\n// 3. Use the resulting rankingInfo.rank to sort\n\n// For bundling purposes (mainly remove-accents not being esm safe/ready),\n// we've also hard-coded remove-accents into this source.\n// The remove-accents package is still included as a dependency\n// for attribution purposes, but it will not be imported and bundled.\n\nimport { removeAccents } from './remove-accents'\n\nexport type AccessorAttributes = {\n  threshold?: Ranking\n  maxRanking: Ranking\n  minRanking: Ranking\n}\n\nexport interface RankingInfo {\n  rankedValue: any\n  rank: Ranking\n  accessorIndex: number\n  accessorThreshold: Ranking | undefined\n  passed: boolean\n}\n\nexport interface AccessorOptions<TItem> {\n  accessor: AccessorFn<TItem>\n  threshold?: Ranking\n  maxRanking?: Ranking\n  minRanking?: Ranking\n}\n\nexport type AccessorFn<TItem> = (item: TItem) => string | Array<string>\n\nexport type Accessor<TItem> = AccessorFn<TItem> | AccessorOptions<TItem>\n\nexport interface RankItemOptions<TItem = unknown> {\n  accessors?: ReadonlyArray<Accessor<TItem>>\n  threshold?: Ranking\n  keepDiacritics?: boolean\n}\n\nexport const rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0,\n} as const\n\nexport type Ranking = (typeof rankings)[keyof typeof rankings]\n\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */\nexport function rankItem<TItem>(\n  item: TItem,\n  value: string,\n  options?: RankItemOptions<TItem>\n): RankingInfo {\n  options = options || {}\n\n  options.threshold = options.threshold ?? rankings.MATCHES\n\n  if (!options.accessors) {\n    // if keys is not specified, then we assume the item given is ready to be matched\n    const rank = getMatchRanking(item as unknown as string, value, options)\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedValue: item,\n      rank,\n      accessorIndex: -1,\n      accessorThreshold: options.threshold,\n      passed: rank >= options.threshold,\n    }\n  }\n\n  const valuesToRank = getAllValuesToRank(item, options.accessors)\n\n  const rankingInfo: RankingInfo = {\n    rankedValue: item,\n    rank: rankings.NO_MATCH as Ranking,\n    accessorIndex: -1,\n    accessorThreshold: options.threshold,\n    passed: false,\n  }\n\n  for (let i = 0; i < valuesToRank.length; i++) {\n    const rankValue = valuesToRank[i]!\n\n    let newRank = getMatchRanking(rankValue.itemValue, value, options)\n\n    const {\n      minRanking,\n      maxRanking,\n      threshold = options.threshold,\n    } = rankValue.attributes\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking\n    }\n\n    newRank = Math.min(newRank, maxRanking) as Ranking\n\n    if (newRank >= threshold && newRank > rankingInfo.rank) {\n      rankingInfo.rank = newRank\n      rankingInfo.passed = true\n      rankingInfo.accessorIndex = i\n      rankingInfo.accessorThreshold = threshold\n      rankingInfo.rankedValue = rankValue.itemValue\n    }\n  }\n\n  return rankingInfo\n}\n\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\nfunction getMatchRanking<TItem>(\n  testString: string,\n  stringToRank: string,\n  options: RankItemOptions<TItem>\n): Ranking {\n  testString = prepareValueForComparison(testString, options)\n  stringToRank = prepareValueForComparison(stringToRank, options)\n\n  // too long\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH\n  }\n\n  // case sensitive equals\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL\n  }\n\n  // Lower casing before further comparison\n  testString = testString.toLowerCase()\n  stringToRank = stringToRank.toLowerCase()\n\n  // case insensitive equals\n  if (testString === stringToRank) {\n    return rankings.EQUAL\n  }\n\n  // starts with\n  if (testString.startsWith(stringToRank)) {\n    return rankings.STARTS_WITH\n  }\n\n  // word starts with\n  if (testString.includes(` ${stringToRank}`)) {\n    return rankings.WORD_STARTS_WITH\n  }\n\n  // contains\n  if (testString.includes(stringToRank)) {\n    return rankings.CONTAINS\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH\n  }\n\n  // acronym\n  if (getAcronym(testString).includes(stringToRank)) {\n    return rankings.ACRONYM\n  }\n\n  // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n  return getClosenessRanking(testString, stringToRank)\n}\n\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\nfunction getAcronym(string: string): string {\n  let acronym = ''\n  const wordsInString = string.split(' ')\n  wordsInString.forEach(wordInString => {\n    const splitByHyphenWords = wordInString.split('-')\n    splitByHyphenWords.forEach(splitByHyphenWord => {\n      acronym += splitByHyphenWord.substr(0, 1)\n    })\n  })\n  return acronym\n}\n\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\nfunction getClosenessRanking(\n  testString: string,\n  stringToRank: string\n): Ranking {\n  let matchingInOrderCharCount = 0\n  let charNumber = 0\n  function findMatchingCharacter(\n    matchChar: undefined | string,\n    string: string,\n    index: number\n  ) {\n    for (let j = index, J = string.length; j < J; j++) {\n      const stringChar = string[j]\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1\n        return j + 1\n      }\n    }\n    return -1\n  }\n  function getRanking(spread: number) {\n    const spreadPercentage = 1 / spread\n    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length\n    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage\n    return ranking as Ranking\n  }\n  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0)\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH\n  }\n  charNumber = firstIndex\n  for (let i = 1, I = stringToRank.length; i < I; i++) {\n    const matchChar = stringToRank[i]\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber)\n    const found = charNumber > -1\n    if (!found) {\n      return rankings.NO_MATCH\n    }\n  }\n\n  const spread = charNumber - firstIndex\n  return getRanking(spread)\n}\n\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\nexport function compareItems<TItem>(a: RankingInfo, b: RankingInfo): number {\n  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1\n}\n\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\nfunction prepareValueForComparison<TItem>(\n  value: string,\n  { keepDiacritics }: RankItemOptions<TItem>\n): string {\n  // value might not actually be a string at this point (we don't get to choose)\n  // so part of preparing the value for comparison is ensure that it is a string\n  value = `${value}` // toString\n  if (!keepDiacritics) {\n    value = removeAccents(value)\n  }\n  return value\n}\n\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\nfunction getItemValues<TItem>(\n  item: TItem,\n  accessor: Accessor<TItem>\n): Array<string> {\n  let accessorFn = accessor as AccessorFn<TItem>\n\n  if (typeof accessor === 'object') {\n    accessorFn = accessor.accessor\n  }\n\n  const value = accessorFn(item)\n\n  // because `value` can also be undefined\n  if (value == null) {\n    return []\n  }\n\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  return [String(value)]\n}\n\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */\nfunction getAllValuesToRank<TItem>(\n  item: TItem,\n  accessors: ReadonlyArray<Accessor<TItem>>\n) {\n  const allValues: Array<{\n    itemValue: string\n    attributes: AccessorAttributes\n  }> = []\n  for (let j = 0, J = accessors.length; j < J; j++) {\n    const accessor = accessors[j]!\n    const attributes = getAccessorAttributes(accessor)\n    const itemValues = getItemValues(item, accessor)\n    for (let i = 0, I = itemValues.length; i < I; i++) {\n      allValues.push({\n        itemValue: itemValues[i]!,\n        attributes,\n      })\n    }\n  }\n  return allValues\n}\n\nconst defaultKeyAttributes = {\n  maxRanking: Infinity as Ranking,\n  minRanking: -Infinity as Ranking,\n}\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */\nfunction getAccessorAttributes<TItem>(\n  accessor: Accessor<TItem>\n): AccessorAttributes {\n  if (typeof accessor === 'function') {\n    return defaultKeyAttributes\n  }\n  return { ...defaultKeyAttributes, ...accessor }\n}\n", "import type { Query } from '@tanstack/query-core'\n\ntype SortFn = (a: Query, b: Query) => number\n\n// eslint-disable-next-line no-shadow\nenum QueryState {\n  Fetching = 0,\n  Fresh,\n  Stale,\n  Inactive,\n  Paused,\n}\n\nexport function getQueryState(query: Query): QueryState {\n  if (query.state.fetchStatus === 'fetching') {\n    return QueryState.Fetching\n  }\n  if (query.state.fetchStatus === 'paused') {\n    return QueryState.Paused\n  }\n  if (!query.getObserversCount()) {\n    return QueryState.Inactive\n  }\n  if (query.isStale()) {\n    return QueryState.Stale\n  }\n\n  return QueryState.Fresh\n}\n\nexport function getQueryStateLabel(query: Query): string {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 'fetching'\n  }\n  if (queryState === QueryState.Paused) {\n    return 'paused'\n  }\n  if (queryState === QueryState.Stale) {\n    return 'stale'\n  }\n  if (queryState === QueryState.Inactive) {\n    return 'inactive'\n  }\n\n  return 'fresh'\n}\n\nexport function getQueryStatusFg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Stale) {\n    return 0x000000\n  }\n\n  return 0xffffff\n}\n\nexport function getQueryStatusBg(query: Query): number {\n  const queryState = getQueryState(query)\n\n  if (queryState === QueryState.Fetching) {\n    return 0x006bff\n  }\n  if (queryState === QueryState.Paused) {\n    return 0x8c49eb\n  }\n  if (queryState === QueryState.Stale) {\n    return 0xffb200\n  }\n  if (queryState === QueryState.Inactive) {\n    return 0x3f4e60\n  }\n\n  return 0x008327\n}\n\nconst queryHashSort: SortFn = (a, b) => a.queryHash.localeCompare(b.queryHash)\n\nconst dateSort: SortFn = (a, b) =>\n  a.state.dataUpdatedAt < b.state.dataUpdatedAt ? 1 : -1\n\nconst statusAndDateSort: SortFn = (a, b) => {\n  if (getQueryState(a) === getQueryState(b)) {\n    return dateSort(a, b)\n  }\n\n  return getQueryState(a) > getQueryState(b) ? 1 : -1\n}\n\nexport const sortFns: Record<string, SortFn> = {\n  'Status > Last Updated': statusAndDateSort,\n  'Query Hash': queryHashSort,\n  'Last Updated': dateSort,\n}\n", "import { setupDevtoolsPlugin } from '@vue/devtools-api'\nimport { rankItem } from '@tanstack/match-sorter-utils'\nimport { onlineManager } from '@tanstack/query-core'\nimport {\n  getQueryStateLabel,\n  getQueryStatusBg,\n  getQueryStatusFg,\n  sortFns,\n} from './utils'\nimport type { CustomInspectorNode } from '@vue/devtools-api'\nimport type { Query, QueryCacheNotifyEvent } from '@tanstack/query-core'\nimport type { QueryClient } from '../queryClient'\n\nconst pluginId = 'vue-query'\nconst pluginName = 'Vue Query'\n\nexport function setupDevtools(app: any, queryClient: QueryClient) {\n  setupDevtoolsPlugin(\n    {\n      id: pluginId,\n      label: pluginName,\n      packageName: 'vue-query',\n      homepage: 'https://tanstack.com/query/latest',\n      logo: 'https://raw.githubusercontent.com/TanStack/query/main/packages/vue-query/media/vue-query.svg',\n      app,\n      settings: {\n        baseSort: {\n          type: 'choice',\n          component: 'button-group',\n          label: 'Sort Cache Entries',\n          options: [\n            {\n              label: 'ASC',\n              value: 1,\n            },\n            {\n              label: 'DESC',\n              value: -1,\n            },\n          ],\n          defaultValue: 1,\n        },\n        sortFn: {\n          type: 'choice',\n          label: 'Sort Function',\n          options: Object.keys(sortFns).map((key) => ({\n            label: key,\n            value: key,\n          })),\n          defaultValue: Object.keys(sortFns)[0]!,\n        },\n        onlineMode: {\n          type: 'choice',\n          component: 'button-group',\n          label: 'Online mode',\n          options: [\n            {\n              label: 'Online',\n              value: 1,\n            },\n            {\n              label: 'Offline',\n              value: 0,\n            },\n          ],\n          defaultValue: 1,\n        },\n      },\n    },\n    (api) => {\n      const initialSettings = api.getSettings()\n      onlineManager.setOnline(Boolean(initialSettings.onlineMode.valueOf()))\n\n      const queryCache = queryClient.getQueryCache()\n\n      api.addInspector({\n        id: pluginId,\n        label: pluginName,\n        icon: 'api',\n        nodeActions: [\n          {\n            icon: 'file_download',\n            tooltip: 'Refetch',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.fetch()\n            },\n          },\n          {\n            icon: 'alarm',\n            tooltip: 'Invalidate',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryClient.invalidateQueries(query)\n            },\n          },\n          {\n            icon: 'settings_backup_restore',\n            tooltip: 'Reset',\n            action: (queryHash: string) => {\n              queryCache.get(queryHash)?.reset()\n            },\n          },\n          {\n            icon: 'delete',\n            tooltip: 'Remove',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n              queryCache.remove(query)\n            },\n          },\n          {\n            icon: 'hourglass_empty',\n            tooltip: 'Force loading',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n\n              query.setState({\n                data: undefined,\n                status: 'pending',\n              })\n            },\n          },\n          {\n            icon: 'error_outline',\n            tooltip: 'Force error',\n            action: (queryHash: string) => {\n              const query = queryCache.get(queryHash) as Query\n\n              query.setState({\n                data: undefined,\n                status: 'error',\n                error: new Error('Unknown error from devtools'),\n              })\n            },\n          },\n        ],\n      })\n\n      api.addTimelineLayer({\n        id: pluginId,\n        label: pluginName,\n        color: 0xffd94c,\n      })\n\n      queryCache.subscribe((event) => {\n        api.sendInspectorTree(pluginId)\n        api.sendInspectorState(pluginId)\n\n        const queryEvents: Array<QueryCacheNotifyEvent['type']> = [\n          'added',\n          'removed',\n          'updated',\n        ]\n\n        if (queryEvents.includes(event.type)) {\n          api.addTimelineEvent({\n            layerId: pluginId,\n            event: {\n              title: event.type,\n              subtitle: event.query.queryHash,\n              time: api.now(),\n              data: {\n                queryHash: event.query.queryHash,\n                ...event,\n              },\n            },\n          })\n        }\n      })\n\n      api.on.setPluginSettings((payload) => {\n        if (payload.key === 'onlineMode') {\n          onlineManager.setOnline(Boolean(payload.newValue))\n        }\n      })\n\n      api.on.getInspectorTree((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const queries = queryCache.getAll()\n          const settings = api.getSettings()\n\n          const filtered = payload.filter\n            ? queries.filter(\n                (item) => rankItem(item.queryHash, payload.filter).passed,\n              )\n            : [...queries]\n\n          const sorted = filtered.sort(\n            (a, b) => sortFns[settings.sortFn]!(a, b) * settings.baseSort,\n          )\n\n          const nodes: Array<CustomInspectorNode> = sorted.map((query) => {\n            const stateLabel = getQueryStateLabel(query)\n\n            return {\n              id: query.queryHash,\n              label: query.queryHash,\n              tags: [\n                {\n                  label: `${stateLabel} [${query.getObserversCount()}]`,\n                  textColor: getQueryStatusFg(query),\n                  backgroundColor: getQueryStatusBg(query),\n                },\n              ],\n            }\n          })\n          payload.rootNodes = nodes\n        }\n      })\n\n      api.on.getInspectorState((payload) => {\n        if (payload.inspectorId === pluginId) {\n          const query = queryCache.get(payload.nodeId)\n\n          if (!query) {\n            return\n          }\n\n          payload.state = {\n            ' Query Details': [\n              {\n                key: 'Query key',\n                value: query.queryHash,\n              },\n              {\n                key: 'Query status',\n                value: getQueryStateLabel(query),\n              },\n              {\n                key: 'Observers',\n                value: query.getObserversCount(),\n              },\n              {\n                key: 'Last Updated',\n                value: new Date(query.state.dataUpdatedAt).toLocaleTimeString(),\n              },\n            ],\n            'Data Explorer': [\n              {\n                key: 'Data',\n                value: query.state.data,\n              },\n            ],\n            'Query Explorer': [\n              {\n                key: 'Query',\n                value: query,\n              },\n            ],\n          }\n        }\n      })\n    },\n  )\n}\n", "import { isVue2 } from 'vue-demi'\nimport { isServer } from '@tanstack/query-core'\n\nimport { QueryClient } from './queryClient'\nimport { getClientKey } from './utils'\nimport { setupDevtools } from './devtools/devtools'\nimport type { QueryClientConfig } from '@tanstack/query-core'\n\ntype ClientPersister = (client: QueryClient) => [() => void, Promise<void>]\n\ninterface CommonOptions {\n  queryClientKey?: string\n  clientPersister?: ClientPersister\n  clientPersisterOnSuccess?: (client: QueryClient) => void\n}\n\ninterface ConfigOptions extends CommonOptions {\n  queryClientConfig?: QueryClientConfig\n}\n\ninterface ClientOptions extends CommonOptions {\n  queryClient?: QueryClient\n}\n\nexport type VueQueryPluginOptions = ConfigOptions | ClientOptions\n\nexport const VueQueryPlugin = {\n  install: (app: any, options: VueQueryPluginOptions = {}) => {\n    const clientKey = getClientKey(options.queryClientKey)\n    let client: QueryClient\n\n    if ('queryClient' in options && options.queryClient) {\n      client = options.queryClient\n    } else {\n      const clientConfig =\n        'queryClientConfig' in options ? options.queryClientConfig : undefined\n      client = new QueryClient(clientConfig)\n    }\n\n    if (!isServer) {\n      client.mount()\n    }\n\n    let persisterUnmount = () => {\n      // noop\n    }\n\n    if (options.clientPersister) {\n      client.isRestoring.value = true\n      const [unmount, promise] = options.clientPersister(client)\n      persisterUnmount = unmount\n      promise.then(() => {\n        client.isRestoring.value = false\n        options.clientPersisterOnSuccess?.(client)\n      })\n    }\n\n    const cleanup = () => {\n      client.unmount()\n      persisterUnmount()\n    }\n\n    if (app.onUnmount) {\n      app.onUnmount(cleanup)\n    } else {\n      const originalUnmount = app.unmount\n      app.unmount = function vueQueryUnmount() {\n        cleanup()\n        originalUnmount()\n      }\n    }\n\n    if (isVue2) {\n      app.mixin({\n        beforeCreate() {\n          // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\n          if (!this._provided) {\n            const provideCache = {}\n            Object.defineProperty(this, '_provided', {\n              get: () => provideCache,\n              set: (v) => Object.assign(provideCache, v),\n            })\n          }\n\n          this._provided[clientKey] = client\n\n          if (process.env.NODE_ENV === 'development') {\n            if (this === this.$root) {\n              setupDevtools(this, client)\n            }\n          }\n        },\n      })\n    } else {\n      app.provide(clientKey, client)\n\n      if (process.env.NODE_ENV === 'development') {\n        setupDevtools(app, client)\n      }\n    }\n  },\n}\n", "import type { DataTag, DefaultError, QueryKey } from '@tanstack/query-core'\nimport type {\n  DefinedInitialQueryOptions,\n  UndefinedInitialQueryOptions,\n} from './useQuery'\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TData>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, shouldThrowError, updateState } from './utils'\nimport type { ToRef } from 'vue-demi'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\n\nexport type UseBaseQueryReturnType<\n  TData,\n  TError,\n  Result = QueryObserverResult<TData, TError>,\n> = {\n  [K in keyof Result]: K extends\n    | 'fetchNextPage'\n    | 'fetchPreviousPage'\n    | 'refetch'\n    ? Result[K]\n    : ToRef<Readonly<Result>[K]>\n} & {\n  suspense: () => Promise<Result>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  | UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n  TPageParam,\n>(\n  Observer: typeof QueryObserver,\n  options: UseQueryOptionsGeneric<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseBaseQueryReturnType<TData, TError> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedOptions = computed(() => {\n    const clonedOptions = cloneDeepUnref(options as any)\n\n    if (typeof clonedOptions.enabled === 'function') {\n      clonedOptions.enabled = clonedOptions.enabled()\n    }\n\n    const defaulted: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    > = client.defaultQueryOptions(clonedOptions)\n\n    defaulted._optimisticResults = client.isRestoring.value\n      ? 'isRestoring'\n      : 'optimistic'\n\n    return defaulted\n  })\n\n  const observer = new Observer(client, defaultedOptions.value)\n  const state = reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    client.isRestoring,\n    (isRestoring) => {\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe((result) => {\n          updateState(state, result)\n        })\n      }\n    },\n    { immediate: true },\n  )\n\n  const updater = () => {\n    observer.setOptions(defaultedOptions.value)\n    updateState(state, observer.getCurrentResult())\n  }\n\n  watch(defaultedOptions, updater)\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  // fix #5910\n  const refetch = (...args: Parameters<(typeof state)['refetch']>) => {\n    updater()\n    return state.refetch(...args)\n  }\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>(\n      (resolve, reject) => {\n        let stopWatch = () => {\n          //noop\n        }\n        const run = () => {\n          if (defaultedOptions.value.enabled !== false) {\n            // fix #6133\n            observer.setOptions(defaultedOptions.value)\n            const optimisticResult = observer.getOptimisticResult(\n              defaultedOptions.value,\n            )\n            if (optimisticResult.isStale) {\n              stopWatch()\n              observer\n                .fetchOptimistic(defaultedOptions.value)\n                .then(resolve, reject)\n            } else {\n              stopWatch()\n              resolve(optimisticResult)\n            }\n          }\n        }\n\n        run()\n\n        stopWatch = watch(defaultedOptions, run)\n      },\n    )\n  }\n\n  // Handle error boundary\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        state.isError &&\n        !state.isFetching &&\n        shouldThrowError(defaultedOptions.value.throwOnError, [\n          error as TError,\n          observer.getCurrentQuery(),\n        ])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  const object: any = toRefs(readonly(state))\n  for (const key in state) {\n    if (typeof state[key as keyof typeof state] === 'function') {\n      object[key] = state[key as keyof typeof state]\n    }\n  }\n\n  object.suspense = suspense\n  object.refetch = refetch\n\n  return object as UseBaseQueryReturnType<TData, TError>\n}\n", "import { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueryKey,\n  QueryObserverOptions,\n  WithRequired,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryReturnType } from './useBaseQuery'\nimport type {\n  DeepUnwrapRef,\n  MaybeRef,\n  MaybeRefDeep,\n  MaybeRefOrGetter,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\ntype NonUndefinedGuard<T> = T extends undefined ? never : T\n\nexport type UseQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = MaybeRef<{\n  [Property in keyof QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >]: Property extends 'queryFn' | 'select'\n    ? QueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        DeepUnwrapRef<TQueryKey>\n      >[Property]\n    : Property extends 'enabled'\n      ? MaybeRefOrGetter<\n          QueryObserverOptions<\n            TQueryFnData,\n            TError,\n            TData,\n            TQueryData,\n            TQueryKey\n          >[Property]\n        >\n      : MaybeRefDeep<\n          WithRequired<\n            QueryObserverOptions<\n              TQueryFnData,\n              TError,\n              TData,\n              TQueryData,\n              TQueryKey\n            >,\n            'queryKey'\n          >[Property]\n        >\n}>\n\nexport type UndefinedInitialQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> & {\n  initialData?: undefined\n}\n\nexport type DefinedInitialQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n}\n\nexport type UseQueryReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError\n>\n\nexport type UseQueryDefinedReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError,\n  DefinedQueryObserverResult<TData, TError>\n>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryDefinedReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n  queryClient?: QueryClient,\n): UseQueryReturnType<TData, TError>\n\nexport function useQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey\n  >,\n  queryClient?: QueryClient,\n):\n  | UseQueryReturnType<TData, TError>\n  | UseQueryDefinedReturnType<TData, TError> {\n  return useBaseQuery(QueryObserver, options, queryClient)\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { QueriesObserver } from '@tanstack/query-core'\nimport {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  ref,\n  watch,\n} from 'vue-demi'\n\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  DefinedQueryObserverResult,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryFunction,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './useQuery'\nimport type { QueryClient } from './queryClient'\nimport type { DeepUnwrapRef, DistributiveOmit, MaybeRefDeep } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = DistributiveOmit<\n  UseQueryOptions<TQueryFnData, TError, TData, unknown, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: if UseQueryOptions are already being sent through, then just return T\n  T extends UseQueryOptions\n    ? DeepUnwrapRef<T>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n      T extends {\n          queryFnData: infer TQueryFnData\n          error?: infer TError\n          data: infer TData\n        }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n          : // Part 3: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n            T extends [infer TQueryFnData, infer TError, infer TData]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n            : T extends [infer TQueryFnData, infer TError]\n              ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? UseQueryOptionsForUseQueries<TQueryFnData>\n                : // Part 4: responsible for inferring and enforcing type if no explicit parameter was provided\n                  T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      TError,\n                      TData,\n                      TQueryKey\n                    >\n                  : T extends {\n                        queryFn?: QueryFunction<\n                          infer TQueryFnData,\n                          infer TQueryKey\n                        >\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? UseQueryOptionsForUseQueries<\n                        TQueryFnData,\n                        TError,\n                        TQueryFnData,\n                        TQueryKey\n                      >\n                    : // Fallback\n                      UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedQueryObserverResult rather than QueryObserverResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? QueryObserverResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedQueryObserverResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? QueryObserverResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedQueryObserverResult<TData, TError>\n            : QueryObserverResult<TData, TError>\n        : QueryObserverResult<TData, TError>\n  : QueryObserverResult<TData, TError>\n\ntype GetResults<T> =\n  // Part 1: if using UseQueryOptions then the types are already set\n  T extends UseQueryOptions<\n    infer TQueryFnData,\n    infer TError,\n    infer TData,\n    any,\n    any\n  >\n    ? GetDefinedOrUndefinedQueryResult<\n        T,\n        undefined extends TData ? TQueryFnData : TData,\n        TError\n      >\n    : // Part 2: responsible for mapping explicit type parameter to function result, if object\n      T extends { queryFnData: any; error?: infer TError; data: infer TData }\n      ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n      : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n        : T extends { data: infer TData; error?: infer TError }\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : // Part 3: responsible for mapping explicit type parameter to function result, if tuple\n            T extends [any, infer TError, infer TData]\n            ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n            : T extends [infer TQueryFnData, infer TError]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n              : T extends [infer TQueryFnData]\n                ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n                : // Part 4: responsible for mapping inferred type to results, if no explicit parameter was provided\n                  T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      select?: (data: any) => infer TData\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? GetDefinedOrUndefinedQueryResult<\n                      T,\n                      unknown extends TData ? TQueryFnData : TData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : T extends {\n                        queryFn?: QueryFunction<infer TQueryFnData, any>\n                        throwOnError?: ThrowOnError<any, infer TError, any, any>\n                      }\n                    ? GetDefinedOrUndefinedQueryResult<\n                        T,\n                        TQueryFnData,\n                        unknown extends TError ? DefaultError : TError\n                      >\n                    : // Fallback\n                      QueryObserverResult\n\n/**\n * UseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type UseQueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? UseQueriesOptions<\n            [...Tail],\n            [...Result, GetOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * UseQueriesResults reducer recursively maps type param to results\n */\nexport type UseQueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<QueryObserverResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? UseQueriesResults<\n            [...Tail],\n            [...Result, GetResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              QueryObserverResult<\n                unknown extends TData ? TQueryFnData : TData,\n                TError\n              >\n            >\n          : // Fallback\n            Array<QueryObserverResult>\n\ntype UseQueriesOptionsArg<T extends Array<any>> = readonly [\n  ...UseQueriesOptions<T>,\n]\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = UseQueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: MaybeRefDeep<UseQueriesOptionsArg<T>>\n    combine?: (result: UseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): Readonly<Ref<TCombinedResult>> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedQueries = computed(() =>\n    cloneDeepUnref(queries).map((queryOptions) => {\n      if (typeof queryOptions.enabled === 'function') {\n        queryOptions.enabled = queryOptions.enabled()\n      }\n\n      const defaulted = client.defaultQueryOptions(queryOptions)\n      defaulted._optimisticResults = client.isRestoring.value\n        ? 'isRestoring'\n        : 'optimistic'\n\n      return defaulted\n    }),\n  )\n\n  const observer = new QueriesObserver<TCombinedResult>(\n    client,\n    defaultedQueries.value,\n    options as QueriesObserverOptions<TCombinedResult>,\n  )\n  const [, getCombinedResult] = observer.getOptimisticResult(\n    defaultedQueries.value,\n    (options as QueriesObserverOptions<TCombinedResult>).combine,\n  )\n  const state = ref(getCombinedResult()) as Ref<TCombinedResult>\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  watch(\n    client.isRestoring,\n    (isRestoring) => {\n      if (!isRestoring) {\n        unsubscribe()\n        unsubscribe = observer.subscribe(() => {\n          const [, getCombinedResultRestoring] = observer.getOptimisticResult(\n            defaultedQueries.value,\n            (options as QueriesObserverOptions<TCombinedResult>).combine,\n          )\n          state.value = getCombinedResultRestoring()\n        })\n        // Subscription would not fire for persisted results\n        const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n          defaultedQueries.value,\n          (options as QueriesObserverOptions<TCombinedResult>).combine,\n        )\n        state.value = getCombinedResultPersisted()\n      }\n    },\n    { immediate: true },\n  )\n\n  watch(\n    defaultedQueries,\n    () => {\n      observer.setQueries(\n        defaultedQueries.value,\n        options as QueriesObserverOptions<TCombinedResult>,\n      )\n      const [, getCombinedResultPersisted] = observer.getOptimisticResult(\n        defaultedQueries.value,\n        (options as QueriesObserverOptions<TCombinedResult>).combine,\n      )\n      state.value = getCombinedResultPersisted()\n    },\n    { flush: 'sync' },\n  )\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state) as Readonly<Ref<TCombinedResult>>\n}\n", "import { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  InfiniteData,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n  QueryObserver,\n  WithRequired,\n} from '@tanstack/query-core'\n\nimport type { UseBaseQueryReturnType } from './useBaseQuery'\n\nimport type { DeepUnwrapRef, MaybeRefDeep, MaybeRefOrGetter } from './types'\nimport type { QueryClient } from './queryClient'\n\nexport type UseInfiniteQueryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = {\n  [Property in keyof InfiniteQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey,\n    TPageParam\n  >]: Property extends\n    | 'queryFn'\n    | 'getPreviousPageParam'\n    | 'getNextPageParam'\n    | 'select'\n    ? InfiniteQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        DeepUnwrapRef<TQueryKey>,\n        TPageParam\n      >[Property]\n    : Property extends 'enabled'\n      ? MaybeRefOrGetter<\n          InfiniteQueryObserverOptions<\n            TQueryFnData,\n            TError,\n            TData,\n            TQueryData,\n            TQueryKey\n          >[Property]\n        >\n      : MaybeRefDeep<\n          WithRequired<\n            InfiniteQueryObserverOptions<\n              TQueryFnData,\n              TError,\n              TData,\n              TQueryData,\n              TQueryKey,\n              TPageParam\n            >,\n            'queryKey'\n          >[Property]\n        >\n}\n\nexport type UseInfiniteQueryReturnType<TData, TError> = UseBaseQueryReturnType<\n  TData,\n  TError,\n  InfiniteQueryObserverResult<TData, TError>\n>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryFnData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryReturnType<TData, TError> {\n  return useBaseQuery(\n    InfiniteQueryObserver as typeof QueryObserver,\n    options,\n    queryClient,\n  ) as UseInfiniteQueryReturnType<TData, TError>\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  toRefs,\n  watch,\n} from 'vue-demi'\nimport { MutationObserver } from '@tanstack/query-core'\nimport { cloneDeepUnref, shouldThrowError, updateState } from './utils'\nimport { useQueryClient } from './useQueryClient'\nimport type { ToRefs } from 'vue-demi'\nimport type {\n  DefaultError,\n  MutateFunction,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from '@tanstack/query-core'\nimport type { DistributiveOmit, MaybeRefDeep } from './types'\nimport type { QueryClient } from './queryClient'\n\ntype MutationResult<TData, TError, TVariables, TContext> = DistributiveOmit<\n  MutationObserverResult<TData, TError, TVariables, TContext>,\n  'mutate' | 'reset'\n>\n\nexport type UseMutationOptions<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = MaybeRefDeep<MutationObserverOptions<TData, TError, TVariables, TContext>>\n\ntype MutateSyncFunction<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> = (\n  ...options: Parameters<MutateFunction<TData, TError, TVariables, TContext>>\n) => void\n\nexport type UseMutationReturnType<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n  Result = MutationResult<TData, TError, TVariables, TContext>,\n> = ToRefs<Readonly<Result>> & {\n  mutate: MutateSyncFunction<TData, TError, TVariables, TContext>\n  mutateAsync: MutateFunction<TData, TError, TVariables, TContext>\n  reset: MutationObserverResult<TData, TError, TVariables, TContext>['reset']\n}\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  mutationOptions: MaybeRefDeep<\n    MutationObserverOptions<TData, TError, TVariables, TContext>\n  >,\n  queryClient?: QueryClient,\n): UseMutationReturnType<TData, TError, TVariables, TContext> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n  const options = computed(() => {\n    return client.defaultMutationOptions(cloneDeepUnref(mutationOptions))\n  })\n  const observer = new MutationObserver(client, options.value)\n  const state = reactive(observer.getCurrentResult())\n\n  const unsubscribe = observer.subscribe((result) => {\n    updateState(state, result)\n  })\n\n  const mutate = (\n    variables: TVariables,\n    mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(() => {\n      // This is intentional\n    })\n  }\n\n  watch(options, () => {\n    observer.setOptions(options.value)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  const resultRefs = toRefs(readonly(state)) as unknown as ToRefs<\n    Readonly<MutationResult<TData, TError, TVariables, TContext>>\n  >\n\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        error &&\n        shouldThrowError(options.value.throwOnError, [error as TError])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  return {\n    ...resultRefs,\n    mutate,\n    mutateAsync: state.mutate,\n    reset: state.reset,\n  }\n}\n", "import { getCurrentScope, onScopeDispose, ref, watchEffect } from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport type { Ref } from 'vue-demi'\nimport type { QueryFilters as QF } from '@tanstack/query-core'\nimport type { MaybeRefDeep } from './types'\nimport type { QueryClient } from './queryClient'\n\nexport type QueryFilters = MaybeRefDeep<QF>\n\nexport function useIsFetching(\n  fetchingFilters: MaybeRefDeep<QF> = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const isFetching = ref()\n\n  const listener = () => {\n    isFetching.value = client.isFetching(fetchingFilters)\n  }\n\n  const unsubscribe = client.getQueryCache().subscribe(listener)\n\n  watchEffect(listener)\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return isFetching\n}\n", "import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  readonly,\n  ref,\n  watch,\n} from 'vue-demi'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref } from './utils'\nimport type { DeepReadonly, Ref } from 'vue-demi'\nimport type {\n  DefaultError,\n  MutationFilters as MF,\n  Mutation,\n  MutationState,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { MaybeRefDeep } from './types'\nimport type { MutationCache } from './mutationCache'\n\nexport type MutationFilters = MaybeRefDeep<MF>\n\nexport function useIsMutating(\n  filters: MutationFilters = {},\n  queryClient?: QueryClient,\n): Ref<number> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composables like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n  const unreffedFilters = computed(() => ({\n    ...cloneDeepUnref(filters),\n    status: 'pending' as const,\n  }))\n\n  const mutationState = useMutationState({ filters: unreffedFilters }, client)\n  const length = computed(() => mutationState.value.length)\n\n  return length\n}\n\nexport type MutationStateOptions<TResult = MutationState> = {\n  filters?: MutationFilters\n  select?: (\n    mutation: Mutation<unknown, DefaultError, unknown, unknown>,\n  ) => TResult\n}\n\nfunction getResult<TResult = MutationState>(\n  mutationCache: MutationCache,\n  options: MutationStateOptions<TResult>,\n): Array<TResult> {\n  return mutationCache\n    .findAll(options.filters)\n    .map(\n      (mutation): TResult =>\n        (options.select\n          ? options.select(\n              mutation as Mutation<unknown, DefaultError, unknown, unknown>,\n            )\n          : mutation.state) as TResult,\n    )\n}\n\nexport function useMutationState<TResult = MutationState>(\n  options: MutationStateOptions<TResult> = {},\n  queryClient?: QueryClient,\n): DeepReadonly<Ref<Array<TResult>>> {\n  const filters = computed(() => cloneDeepUnref(options.filters))\n  const mutationCache = (queryClient || useQueryClient()).getMutationCache()\n  const state = ref(getResult(mutationCache, options)) as Ref<Array<TResult>>\n  const unsubscribe = mutationCache.subscribe(() => {\n    const result = getResult(mutationCache, options)\n    state.value = result\n  })\n\n  watch(filters, () => {\n    state.value = getResult(mutationCache, options)\n  })\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  return readonly(state)\n}\n"],
  "mappings": "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C,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,GAAG;EACHC,GAAG;EACHC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,IAAI;EACJC,I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",
  "names": ["_a", "_a", "_cleanup", "_setup", "_a", "_a", "_a", "_b", "_d", "_c", "_a", "_a", "_dispatch", "_observers", "_defaultOptions", "_retryer", "getDefaultState", "dispatch_fn", "_a", "_a", "_a", "_mutationCache", "_defaultOptions", "_a", "_a", "_notify", "_client", "_queries", "_observers", "notify_fn", "_a", "_a", "_notify", "_client", "_currentResult", "notify_fn", "getDefaultState", "_a", "isPlainObject", "QueryCache", "MutationCache", "QueryClient", "QueryCache", "MutationCache", "characterMap", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "c", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "K", "k", "", "", "", "", "", "", "", "", "", "", "", "", "M", "m", "", "", "", "", "", "", "", "N", "n", "", "", "", "", "", "", "", "", "P", "p", "", "", "", "", "", "", "R", "r", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "T", "t", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "V", "v", "", "", "", "", "X", "x", "", "", "", "Y", "y", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "X", "x", "", "", "", "", "A", "a", "E", "e", "I", "i", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "B", "b", "", "", "", "", "F", "f", "", "", "", "", "J", "", "", "", "M", "m", "P", "p", "Q", "q", "", "", "", "", "V", "v", "W", "w", "X", "x", "Y", "y", "A", "a", "B", "b", "", "", "", "", "", "", "", "", "I", "i", "", "", "M", "m", "O", "o", "Q", "q", "U", "u", "X", "x", "Z", "z", "chars", "Object", "keys", "join", "allAccents", "RegExp", "removeAccents", "str", "replace", "match", "rankings", "CASE_SENSITIVE_EQUAL", "EQUAL", "STARTS_WITH", "WORD_STARTS_WITH", "CONTAINS", "ACRONYM", "MATCHES", "NO_MATCH", "rankItem", "item", "value", "options", "_options$threshold", "threshold", "accessors", "rank", "getMatchRanking", "rankedValue", "accessorIndex", "accessorThreshold", "passed", "valuesToRank", "getAllValuesToRank", "rankingInfo", "i", "length", "rankValue", "newRank", "itemValue", "minRanking", "maxRanking", "attributes", "Math", "min", "testString", "stringToRank", "prepareValueForComparison", "toLowerCase", "startsWith", "includes", "getAcronym", "getClosenessRanking", "string", "acronym", "wordsInString", "split", "forEach", "wordInString", "splitByHyphenWords", "splitByHyphenWord", "substr", "matchingInOrderCharCount", "charNumber", "findMatchingCharacter", "matchChar", "index", "j", "J", "stringChar", "getRanking", "spread", "spreadPercentage", "inOrderPercentage", "ranking", "firstIndex", "I", "found", "prepareValueForComparison", "value", "_ref", "keepDiacritics", "removeAccents", "getItemValues", "item", "accessor", "accessorFn", "Array", "isArray", "String", "getAllValuesToRank", "accessors", "allValues", "j", "J", "length", "attributes", "getAccessorAttributes", "itemValues", "i", "I", "push", "itemValue", "defaultKeyAttributes", "maxRanking", "Infinity", "minRanking", "_a", "QueryClient", "_a", "queryOptions"]
}
